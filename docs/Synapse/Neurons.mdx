---
slug: /Synapse/Creating-Neurons
id: Creating-Neurons
title: 'Creating Neurons & Placeholders'
sidebar_position: 3
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Creating Neurons & Registering Placeholders

Neurons are the core components of Synapse that process and resolve placeholders. This guide covers everything you need to know about creating custom neurons and registering different types of placeholders.

---
## Understanding Neurons

A **Neuron** is a platform-specific placeholder processor that:
- Handles placeholder resolution for a specific namespace
- Manages placeholder registration and lifecycle
- Provides context-aware placeholder processing
- Supports both synchronous and asynchronous operations

## Creating Your First Neuron

<Tabs groupId="synapse-platforms">
  <TabItem value="bukkit" label="Bukkit/Paper">

```java
public class MyCustomNeuron extends BukkitNeuron {
    
    public MyCustomNeuron(Plugin plugin) {
        super(plugin, Namespace.of("custom"));
        registerPlaceholders();
    }
    
    private void registerPlaceholders() {
        // Register your placeholders here
        register("hello", "Hello World!");
        register("server_name", () -> getPlugin().getServer().getName());
    }
}
```

  </TabItem>
  <TabItem value="bungee" label="BungeeCord">

```java
public class MyCustomNeuron extends BungeeNeuron {
    
    public MyCustomNeuron(Plugin plugin) {
        super(plugin, Namespace.of("custom"));
        registerPlaceholders();
    }
    
    private void registerPlaceholders() {
        register("hello", "Hello World!");
        register("proxy_name", () -> getPlugin().getProxy().getName());
    }
}
```

  </TabItem>
  <TabItem value="velocity" label="Velocity">

```java
public class MyCustomNeuron extends VelocityNeuron {
    
    public MyCustomNeuron(PluginContainer plugin) {
        super(plugin, Namespace.of("custom"));
        registerPlaceholders();
    }
    
    private void registerPlaceholders() {
        register("hello", "Hello World!");
        register("proxy_version", () -> getPlugin().getDescription().getVersion());
    }
}
```

  </TabItem>
</Tabs>

## Registering Your Neuron

After creating your neuron, register it with Synapse:

<Tabs groupId="synapse-platforms">
  <TabItem value="bukkit" label="Bukkit/Paper">

```java
@Override
public void onEnable() {
    new MyCustomNeuron(this).register();
}
```

  </TabItem>
  <TabItem value="bungee" label="BungeeCord">

```java
@Override
public void onEnable() {
    new MyCustomNeuron(this).register();
}
```

  </TabItem>
  <TabItem value="velocity" label="Velocity">

```java
@Subscribe
public void onProxyInitialization(ProxyInitializeEvent event) {
    new MyCustomNeuron(this).register();
}
```

  </TabItem>
</Tabs>

---
## Types of Placeholders

### 1. Static Placeholders

Static placeholders return fixed values or values from suppliers that don't depend on user context.

```java
public class StaticNeuron extends BukkitNeuron {
    
    public StaticNeuron(Plugin plugin) {
        super(plugin, Namespace.of("static"));
        
        // Fixed string value
        register("version", "1.0.0");
        
        // Dynamic value using supplier
        register("time", () -> LocalTime.now().toString());
        
        // With aliases
        register("server_name", () -> Bukkit.getServer().getName(), "name", "servername");
    }
}
```

**Usage:**
```java
String result = synapse.translate("Version: ${static.version}", player);
// Result: "Version: 1.0.0"

String time = synapse.translate("Current time: ${static.time}", player);
// Result: "Current time: 14:30:25.123"
```

### 2. Contextual Placeholders

Contextual placeholders depend on user context and receive a `Context<U>` parameter.

```java
public class PlayerNeuron extends BukkitNeuron {
    
    public PlayerNeuron(Plugin plugin) {
        super(plugin, Namespace.of("player"));
        
        // Basic contextual placeholder - works with any CommandSender
        register("name", context -> context.user().getName());
        
        // Player-specific placeholder using requirePlayer()
        register("health", context -> {
            Player player = context.user().requirePlayer();
            return String.format("%.1f", player.getHealth());
        });
        
        // Placeholder with argument handling
        register("stats", context -> {
            Player player = context.user().requirePlayer();
            String[] args = context.arguments();
            if (args.length > 0) {
                Statistic stat = Statistic.valueOf(args[0].toUpperCase());
                return String.valueOf(player.getStatistic(stat));
            }
            return "No statistic specified";
        });
        
        // Location-based placeholder
        register("world", context -> {
            Player player = context.user().requirePlayer();
            Location loc = player.getLocation();
            return loc.getWorld().getName();
        });
    }
}
```

**Usage:**
```java
String name = synapse.translate("Hello ${player.name}!", player);
// Result: "Hello Steve!"

String health = synapse.translate("Health: ${player.health}", player);
// Result: "Health: 20.0"

String stat = synapse.translate("Deaths: ${player.stats:DEATHS}", player);
// Result: "Deaths: 5"
```

### 3. Relational Placeholders

Relational placeholders work with two users and are useful for comparisons or relationships.

```java
public class RelationNeuron extends BukkitNeuron {
    
    public RelationNeuron(Plugin plugin) {
        super(plugin, Namespace.of("rel"));
        
        // Compare player names
        registerRelational("same_name", context -> {
            String name1 = context.user().getName();
            String name2 = context.other().getName();
            return name1.equals(name2) ? "yes" : "no";
        });
        
        // Distance between players - requires both to be players
        registerRelational("distance", context -> {
            Player player1 = context.user().requirePlayer();
            Player player2 = context.other().requirePlayer();
            
            Location loc1 = player1.getLocation();
            Location loc2 = player2.getLocation();
            double distance = loc1.distance(loc2);
            return String.format("%.2f", distance);
        });
        
        // Mixed example - check if users are in same world
        registerRelational("same_world", context -> {
            Player player1 = context.user().requirePlayer();
            Player player2 = context.other().requirePlayer();
            
            return player1.getWorld().equals(player2.getWorld()) ? "yes" : "no";
        });
    }
}
```

**Usage:**
```java
String same = synapse.translate("Same name: ${rel.same_name}", player1, player2);
// Result: "Same name: no"

String distance = synapse.translate("Distance: ${rel.distance} blocks", player1, player2);
// Result: "Distance: 15.67 blocks"
```

---
## Advanced Placeholder Options

### Static Placeholder Options

Static placeholders support refresh and async options:

```java
register("server_stats", () -> calculateServerStats(),
    options -> {
        options.async(true);           // Run calculation in background thread
        options.refresh(true);         // Enable periodic refresh
        options.delay(30, TimeUnit.SECONDS); // Refresh every 30 seconds
    });
```

**Available Options:**
- `async(boolean)` - Execute the supplier asynchronously (default: `false`)
- `refresh(boolean)` - Enable periodic refresh (default: `false`) 
- `delay(long, TimeUnit)` - Time between refreshes (default: 20 seconds)

**Use Cases:**
- Database queries that should run in background
- Expensive calculations that need periodic updates
- External API calls that might block

### Contextual Placeholder Options

Contextual placeholders support caching based on user context:

```java
register("player_rank", context -> {
    return expensiveRankLookup(context.user().getUniqueId());
}, options -> {
    options.cache(true);                    // Enable caching
    options.cacheTTL(5, TimeUnit.MINUTES);  // Cache for 5 minutes
});
```

**Available Options:**
- `cache(boolean)` - Enable result caching per user (default: `false`)
- `cacheTTL(long, TimeUnit)` - How long to cache results (default: 20 seconds)

**Caching Behavior:**
- Cache key includes user ID, namespace, placeholder name, and arguments
- Each user has their own cached values
- Automatic cleanup when cache expires
- Arguments are part of the cache key (different args = different cache entries)

### Relational Placeholder Options

Relational placeholders also support caching, but with both users considered:

```java
registerRelational("friendship_level", context -> {
    return calculateRelationship(
        context.user().getUniqueId(),
        context.other().getUniqueId()
    );
}, options -> {
    options.cache(true);                    // Cache relationship data
    options.cacheTTL(10, TimeUnit.MINUTES); // Cache for 10 minutes
});
```

**Available Options:**
- `cache(boolean)` - Enable result caching per user pair (default: `false`)
- `cacheTTL(long, TimeUnit)` - How long to cache results (default: 20 seconds)

**Caching Behavior:**
- Cache key includes both user IDs, namespace, placeholder name, and arguments
- Cached from the perspective of the primary user
- Different user pairs create separate cache entries
- Expensive relationship calculations benefit most from caching

---
## Option Usage Examples

### Performance Optimization Scenarios

```java
public class OptimizedNeuron extends BukkitNeuron {
    
    public OptimizedNeuron(Plugin plugin) {
        super(plugin, Namespace.of("optimized"));
        
        // Heavy calculation - run async with refresh
        register("server_load", () -> {
            // Simulate heavy CPU calculation
            return String.format("%.1f%%", calculateCPUUsage());
        }, options -> {
            options.async(true);        // Don't block main thread
            options.refresh(true);      // Keep value updated
            options.delay(15, TimeUnit.SECONDS); // Update every 15s
        });
        
        // Database lookup - cache per user
        register("user_data", context -> {
            return queryUserDatabase(context.user().getUniqueId());
        }, options -> {
            options.cache(true);        // Cache expensive DB query
            options.cacheTTL(2, TimeUnit.MINUTES);  // Refresh every 2 min
        });
        
        // API call with arguments - cache with TTL
        register("external_data", context -> {
            String endpoint = context.arguments().length > 0 
                ? context.arguments()[0] 
                : "default";
            return callExternalAPI(endpoint, context.user());
        }, options -> {
            options.cache(true);        // Cache API responses
            options.cacheTTL(1, TimeUnit.MINUTES);   // Short TTL for API data
        });
        
        // Relationship calculation - expensive relational operation
        registerRelational("player_similarity", context -> {
            // Complex algorithm comparing two players
            return calculateSimilarityScore(
                context.user().getUniqueId(),
                context.other().getUniqueId()
            );
        }, options -> {
            options.cache(true);        // Cache relationship calculations
            options.cacheTTL(30, TimeUnit.MINUTES); // Long TTL for relationships
        });
    }
}
```

### Choosing the Right Options

**When to use `async(true)` (Static only):**
- Database operations
- File I/O operations  
- Network requests
- Heavy computations
- Any operation that might block for >50ms

**When to use `cache(true)`:**
- Database lookups
- API calls
- Complex calculations
- File reads
- Any operation repeated frequently with same inputs

**Cache TTL Guidelines:**
- **Short TTL (1-5 minutes)**: Frequently changing data, API responses
- **Medium TTL (5-30 minutes)**: User stats, rankings, moderately dynamic data
- **Long TTL (30+ minutes)**: Relationships, permissions, rarely changing data

**Refresh Guidelines (Static only):**
- **High frequency (1-10 seconds)**: Server stats, online counts
- **Medium frequency (30-60 seconds)**: Resource usage, queue lengths  
- **Low frequency (5+ minutes)**: Configuration values, external service status

This gives you fine-grained control over performance and ensures your placeholders scale well with your server's needs!

## Namespace Management

### Single Namespace

```java
public class SimpleNeuron extends BukkitNeuron {
    public SimpleNeuron(Plugin plugin) {
        super(plugin, Namespace.of("simple"));
        // Accessible as: ${simple.placeholder}
    }
}
```

### Multiple Namespaces

```java
public class MultiNeuron extends BukkitNeuron {
    public MultiNeuron(Plugin plugin) {
        super(plugin, Namespace.of("multi", "m", "multiple"));
        // Accessible as: ${multi.placeholder}, ${m.placeholder}, or ${multiple.placeholder}
    }
}
```

### Empty Namespace (Root Level)

```java
public class RootNeuron extends BukkitNeuron {
    public RootNeuron(Plugin plugin) {
        super(plugin, Namespace.of(""));
        // Accessible as: ${placeholder} (no namespace prefix)
    }
}
```

---
## PlaceholderAPI Integration (Bukkit Only)

For Bukkit, you can easily integrate with PlaceholderAPI:

```java
public class PAPICompatibleNeuron extends BukkitNeuron {
    
    public PAPICompatibleNeuron(Plugin plugin) {
        super(plugin, Namespace.of("myplugin"));
        registerPlaceholders();
        
        // Enable PAPI integration
        hookToPAPI();
    }
    
    private void registerPlaceholders() {
        register("player_balance", context -> {
            Player player = context.user().requirePlayer();
            return String.valueOf(getBalance(player));
        });
    }
}
```

---
## Complete Working Example

Here's a complete example of a feature-rich neuron:

```java
public class ServerInfoNeuron extends BukkitNeuron {
    
    private final Plugin plugin;
    private final AtomicLong lastUpdate = new AtomicLong(0);
    
    public ServerInfoNeuron(Plugin plugin) {
        super(plugin, Namespace.of("server", "srv"));
        this.plugin = plugin;
        registerAllPlaceholders();
    }
    
    private void registerAllPlaceholders() {
        // Static placeholders
        register("name", () -> Bukkit.getServerName());
        register("version", () -> Bukkit.getVersion());
        register("bukkit_version", () -> Bukkit.getBukkitVersion());
        
        // Dynamic placeholders with caching
        register("online", () -> String.valueOf(Bukkit.getOnlinePlayers().size()),
            options -> {
                options.cache(true);
                options.cacheTTL(5, TimeUnit.SECONDS);
            });
        
        register("max_players", () -> String.valueOf(Bukkit.getMaxPlayers()));
        
        // Contextual placeholders
        register("player_world", context -> {
            Player player = context.user().requirePlayer();
            World world = player.getWorld();
            return world != null ? world.getName() : "unknown";
        });
        
        register("tps", context -> {
            // Simulate TPS calculation
            return String.format("%.2f", 20.0);
        }, options -> {
            options.cache(true);
            options.cacheTTL(10, TimeUnit.SECONDS);
        });

        // Placeholder with arguments - using method reference for cleaner code
        register("world_info", this::getWorldInfo);
    }
    
    private String getWorldInfo(Context<BukkitUser> context) {
        String[] args = context.arguments();
        if (args.length == 0) {
            return "Specify: players, entities, or chunks";
        }
        
        Player player = context.user().requirePlayer();
        World world = player.getWorld();
        if (world == null) return "No world";
        
        return switch (args[0].toLowerCase()) {
            case "players" -> String.valueOf(world.getPlayers().size());
            case "entities" -> String.valueOf(world.getEntities().size());
            case "chunks" -> String.valueOf(world.getLoadedChunks().length);
            default -> "Invalid option: " + args[0];
        };
    }
}
```

This neuron provides placeholders like:
- `${server.name}`, `${srv.name}` - Server name
- `${server.online}` - Online player count (cached)
- `${server.player_world}` - Current player's world
- `${server.world_info:players}` - Players in current world

## ðŸ”§ Troubleshooting

### Placeholder Not Resolving

**Problem:** `${custom.placeholder}` returns unchanged

**Solutions:**
1. Verify the neuron is registered: `new MyNeuron(this).register();`
2. Check namespace spelling matches exactly
3. Ensure placeholder is registered in the neuron
4. Check server logs for registration errors

### Player-Only Placeholder Fails with Console

**Problem:** Exception when console uses player-specific placeholder

**Solution:** Use `requirePlayer()` - it handles the error automatically:
```java
register("health", context -> {
    Player player = context.user().requirePlayer(); // Throws exception if not player
    return String.format("%.1f", player.getHealth());
});
```

### Placeholder Returns Stale Data

**Problem:** Cached placeholder shows old value

**Solutions:**
1. Reduce cache TTL: `options.cacheTTL(30, TimeUnit.SECONDS);`
2. Disable caching: `options.cache(false);`
3. Use refresh for static placeholders: `options.refresh(true);`

### Async Placeholder Blocking Server

**Problem:** Server freezes when translating

**Solution:** Use `translateAsync()` for expensive operations:
```java
synapse.translateAsync("${database.query}", player)
    .thenAccept(player::sendMessage);
```